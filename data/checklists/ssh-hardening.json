{
  "id": "ssh-hardening",
  "slug": "ssh-hardening",
  "title": "SSH Hardening Checklist",
  "description": "Comprehensive guide to harden your SSH server configuration and improve security.",
  "category": "Security",
  "difficulty": "intermediate",
  "estimatedTime": "30-45 minutes",
  "tags": ["ssh", "security", "linux", "server", "hardening"],
  "items": [
    {
      "id": "disable-root-login",
      "title": "Disable root login",
      "description": "Preventing direct root login adds an essential security layer. Edit /etc/ssh/sshd_config and set 'PermitRootLogin no'. This forces users to login with their own accounts first, then use sudo for administrative tasks, creating a clear audit trail. After making changes, restart SSH with 'sudo systemctl restart sshd' or 'sudo service ssh restart'. Always test the new configuration in a separate session before closing your current SSH connection.",
      "critical": true
    },
    {
      "id": "change-ssh-port",
      "title": "Change default SSH port",
      "description": "Moving SSH from the default port 22 reduces automated attack attempts. Edit /etc/ssh/sshd_config and change 'Port 22' to a higher port number (e.g., 'Port 2222' or 'Port 22222'). Choose a port above 1024 to avoid conflicts with well-known services. Update your firewall rules to allow the new port and block the old one. Remember to update any SSH clients, scripts, or configuration management tools that connect to this server. Test the new port before closing your current session: 'ssh -p 2222 user@server'.",
      "critical": false
    },
    {
      "id": "enable-key-auth",
      "title": "Enable key-based authentication",
      "description": "SSH keys are far more secure than passwords and resist brute-force attacks. First, generate an SSH key pair on your local machine: 'ssh-keygen -t ed25519 -C \"your_email@example.com\"' (or use RSA 4096-bit if ed25519 isn't supported: 'ssh-keygen -t rsa -b 4096'). Copy your public key to the server: 'ssh-copy-id user@server' or manually append it to ~/.ssh/authorized_keys on the server. Ensure /etc/ssh/sshd_config has 'PubkeyAuthentication yes'. Set proper permissions: 'chmod 700 ~/.ssh' and 'chmod 600 ~/.ssh/authorized_keys'. Test key-based login before disabling password authentication.",
      "critical": true
    },
    {
      "id": "disable-password-auth",
      "title": "Disable password authentication",
      "description": "Once key-based authentication is working, disable passwords entirely to prevent brute-force attacks. Edit /etc/ssh/sshd_config and set 'PasswordAuthentication no' and 'ChallengeResponseAuthentication no'. This forces all users to authenticate with SSH keys only. IMPORTANT: Verify you can login with SSH keys from all necessary locations BEFORE making this change, or you risk locking yourself out. Keep a backup access method (like console access) available. After updating, restart SSH: 'sudo systemctl restart sshd'.",
      "critical": true
    },
    {
      "id": "configure-firewall",
      "title": "Configure firewall rules",
      "description": "Restrict SSH access to known IP addresses or ranges. Using UFW: 'sudo ufw allow from 203.0.113.0/24 to any port 22' (replace with your IP). Using iptables: 'sudo iptables -A INPUT -p tcp -s 203.0.113.0/24 --dport 22 -j ACCEPT' then 'sudo iptables -A INPUT -p tcp --dport 22 -j DROP'. For dynamic IPs, consider VPN access or a bastion host. Cloud providers often have security groups or network ACLs - use those to whitelist IPs at the network level. Test firewall rules carefully to avoid lockout. For multiple locations, add each IP range separately. Save rules permanently: 'sudo iptables-save > /etc/iptables/rules.v4' or 'sudo ufw enable'.",
      "critical": false
    },
    {
      "id": "setup-fail2ban",
      "title": "Set up fail2ban",
      "description": "Fail2ban automatically blocks IPs after repeated failed login attempts. Install: 'sudo apt-get install fail2ban' (Debian/Ubuntu) or 'sudo yum install fail2ban' (RHEL/CentOS). Create local config: 'sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local'. Edit /etc/fail2ban/jail.local and configure the [sshd] section: set 'enabled = true', 'maxretry = 3' (attempts before ban), 'bantime = 3600' (ban duration in seconds), and 'findtime = 600' (time window for max retries). Start and enable: 'sudo systemctl start fail2ban && sudo systemctl enable fail2ban'. Monitor with: 'sudo fail2ban-client status sshd'. Check banned IPs: 'sudo fail2ban-client get sshd banned'.",
      "critical": false
    },
    {
      "id": "enable-2fa",
      "title": "Enable two-factor authentication",
      "description": "Add an extra layer of security beyond SSH keys. Install Google Authenticator PAM module: 'sudo apt-get install libpam-google-authenticator' (Debian/Ubuntu). For each user, run: 'google-authenticator' and scan the QR code with an authenticator app (Google Authenticator, Authy, etc.). Save the emergency codes safely. Edit /etc/pam.d/sshd and add: 'auth required pam_google_authenticator.so' at the top. Edit /etc/ssh/sshd_config: set 'ChallengeResponseAuthentication yes', 'UsePAM yes', and add 'AuthenticationMethods publickey,keyboard-interactive'. Restart SSH. Now users need both their SSH key AND a time-based one-time password (TOTP) code from their authenticator app to login.",
      "critical": false
    },
    {
      "id": "configure-key-permissions",
      "title": "Configure SSH key permissions",
      "description": "Incorrect permissions on SSH files will cause SSH to reject key authentication for security reasons. On the server, ensure the .ssh directory and files have correct permissions: 'chmod 700 ~/.ssh' (only owner can read/write/execute), 'chmod 600 ~/.ssh/authorized_keys' (only owner can read/write). If you have a private key on the server: 'chmod 600 ~/.ssh/id_ed25519' (or id_rsa). The home directory should also have restricted permissions: 'chmod 755 ~' or stricter. Verify ownership: 'ls -la ~/.ssh' should show your username. If permissions are wrong, SSH will ignore the keys and fall back to password auth (if enabled) or deny access entirely.",
      "critical": false
    },
    {
      "id": "ssh-timeouts",
      "title": "Set up SSH session timeouts",
      "description": "Idle SSH sessions are security risks - they can be hijacked if a workstation is left unattended. Edit /etc/ssh/sshd_config and add: 'ClientAliveInterval 300' (sends keepalive every 300 seconds/5 minutes) and 'ClientAliveCountMax 2' (disconnects after 2 failed keepalive responses). This means users will be disconnected after ~10 minutes of inactivity (300 seconds Ã— 2 = 600 seconds). Adjust these values based on your security requirements and user needs. For stricter environments, use 'ClientAliveInterval 180' and 'ClientAliveCountMax 1' for a 3-minute timeout. Restart SSH after changes: 'sudo systemctl restart sshd'.",
      "critical": false
    },
    {
      "id": "disable-empty-passwords",
      "title": "Disable empty passwords",
      "description": "Accounts with empty passwords are critical security vulnerabilities. Edit /etc/ssh/sshd_config and ensure 'PermitEmptyPasswords no' is set (this should be the default, but always verify). This prevents any user account with a blank password from logging in via SSH. Additionally, audit your system for accounts with empty passwords: 'sudo awk -F: '($2 == \"\") {print $1}' /etc/shadow' - this command lists users with no password set. Lock or delete any unnecessary accounts: 'sudo passwd -l username' to lock, or 'sudo userdel username' to remove. Restart SSH after verification: 'sudo systemctl restart sshd'.",
      "critical": true
    },
    {
      "id": "use-protocol-v2",
      "title": "Use SSH protocol version 2",
      "description": "SSH Protocol 1 has known security vulnerabilities and should never be used. Modern SSH servers default to Protocol 2, but it's important to verify. Edit /etc/ssh/sshd_config and explicitly set 'Protocol 2'. On very old systems, you might see 'Protocol 2,1' or 'Protocol 1,2' - remove protocol 1 entirely. Protocol 2 provides stronger encryption, better authentication methods, and protection against known attacks. Note: In OpenSSH 7.0+ (2015), Protocol 1 support was completely removed, so newer systems may not even have this directive. After editing, restart SSH: 'sudo systemctl restart sshd'. Verify with: 'ssh -v user@server' and look for 'Remote protocol version 2.0'.",
      "critical": false
    },
    {
      "id": "configure-allowed-users",
      "title": "Configure allowed users/groups",
      "description": "Explicitly whitelist who can SSH into the server. Edit /etc/ssh/sshd_config and add one of these directives: 'AllowUsers alice bob charlie' (specific usernames), 'AllowUsers alice@192.168.1.* bob@10.0.0.0/8' (users from specific IPs), or 'AllowGroups sshusers administrators' (specific groups). If you use AllowGroups, first create the group: 'sudo groupadd sshusers' and add users: 'sudo usermod -aG sshusers alice'. You can also use DenyUsers or DenyGroups for blacklisting, but whitelisting (Allow) is more secure as it's deny-by-default. Only users/groups explicitly listed will be permitted to SSH. Restart SSH after changes. Test thoroughly before closing your current session to avoid lockout.",
      "critical": false
    }
  ]
}
