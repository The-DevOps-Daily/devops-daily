{
  "id": "linux-quiz",
  "title": "Linux Command Line Quiz",
  "description": "Master the terminal through real-world system administration scenarios covering file management, process control, and troubleshooting",
  "category": "Linux",
  "icon": "Terminal",
  "totalPoints": 140,
  "theme": {
    "primaryColor": "gray",
    "gradientFrom": "from-gray-600",
    "gradientTo": "to-slate-700"
  },
  "metadata": {
    "estimatedTime": "25-30 minutes",
    "difficultyLevels": {
      "beginner": 4,
      "intermediate": 5,
      "advanced": 3
    },
    "createdDate": "2024-08-01"
  },
  "questions": [
    {
      "id": "file-permissions-fix",
      "title": "Permission Denied Emergency",
      "description": "Fix file permissions for a web application that suddenly stopped working.",
      "situation": "Your web server can't read files in /var/www/html after a deployment. The application owner is 'webapp' and group is 'www-data'. Files should be readable by the web server but not writable by others.",
      "codeExample": "Current permissions:\n-rw------- 1 root root index.html\n-rw------- 1 root root style.css\ndrwx------ 2 root root images/",
      "options": [
        "chown -R webapp:www-data /var/www/html && find /var/www/html -type f -exec chmod 644 {} \\; && find /var/www/html -type d -exec chmod 755 {} \\;",
        "chmod 777 /var/www/html/*",
        "chown webapp:www-data /var/www/html/* && chmod 644 /var/www/html/*.* && chmod 755 /var/www/html/*/",
        "chmod -R 755 /var/www/html"
      ],
      "correctAnswer": 0,
      "explanation": "This command properly sets ownership recursively, then sets appropriate permissions: 644 for files (read/write for owner, read for group/others) and 755 for directories (executable needed to enter directories).",
      "hint": "Consider security best practices. Files and directories need different permissions, and you should avoid giving write access to everyone.",
      "difficulty": "beginner",
      "points": 12
    },
    {
      "id": "process-investigation",
      "title": "High CPU Usage Investigation",
      "description": "Identify and manage a process consuming excessive CPU resources.",
      "situation": "Your server's CPU usage is at 95% and users are complaining about slow response times. You need to quickly identify the culprit process and take action.",
      "codeExample": "$ top\n%Cpu(s): 95.2 us,  2.1 sy,  0.0 ni,  2.7 id\nSomething is consuming CPU but top output is scrolling too fast to see clearly.",
      "options": [
        "ps aux | head -10",
        "top -n 1 -o %CPU | head -20",
        "ps aux --sort=-%cpu | head -10",
        "htop --sort-key PERCENT_CPU"
      ],
      "correctAnswer": 2,
      "explanation": "ps aux --sort=-%cpu sorts processes by CPU usage in descending order and shows the top 10 CPU consumers. This gives a clear, static view of which processes are using the most CPU.",
      "hint": "You need a static snapshot sorted by CPU usage to clearly identify the problem process. Which command provides this view?",
      "difficulty": "beginner",
      "points": 10
    },
    {
      "id": "disk-space-cleanup",
      "title": "Disk Space Crisis",
      "description": "Free up disk space when the root filesystem is 98% full.",
      "situation": "Your server's root partition is 98% full and applications are failing. You need to quickly identify what's consuming space and free it up safely.",
      "codeExample": "$ df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sda1        20G   19G  200M  98% /\n\nApplications are logging 'No space left on device' errors.",
      "options": [
        "rm -rf /tmp/* /var/log/*",
        "du -sh /* | sort -hr",
        "du -sh /* 2>/dev/null | sort -hr && du -sh /var/log/* | sort -hr",
        "find / -size +100M -exec ls -lh {} \\;"
      ],
      "correctAnswer": 2,
      "explanation": "This command finds the largest directories in root, suppresses permission errors, and then specifically checks log files which are often safe to clean. It's systematic and avoids dangerous deletions.",
      "hint": "You need to identify what's using space before deleting anything. Which approach safely investigates space usage without risking system files?",
      "difficulty": "beginner",
      "points": 12
    },
    {
      "id": "log-analysis-error",
      "title": "Application Error Investigation",
      "description": "Find error patterns in application logs during a production incident.",
      "situation": "Users reported errors between 14:00-15:00 today. You need to find error messages in the application log file '/var/log/app.log' and count how many occurred.",
      "codeExample": "Log format:\n2024-06-21 14:23:15 INFO User login successful\n2024-06-21 14:24:32 ERROR Database connection failed\n2024-06-21 14:25:01 WARN Cache miss for user:12345\n\nNeed: Find all ERROR messages from 14:00-15:00 hour",
      "options": [
        "grep ERROR /var/log/app.log",
        "grep '2024-06-21 14:.*ERROR' /var/log/app.log | wc -l",
        "awk '/2024-06-21 14:/ && /ERROR/' /var/log/app.log | wc -l",
        "sed -n '/2024-06-21 14:/,/2024-06-21 15:/p' /var/log/app.log | grep ERROR | wc -l"
      ],
      "correctAnswer": 1,
      "explanation": "This grep pattern matches the date, hour (14:), and ERROR in the same line, then counts the occurrences with wc -l. It's precise and efficient for the specific time range needed.",
      "hint": "You need to match both the time pattern and ERROR level. Which command efficiently filters by both criteria and counts the results?",
      "difficulty": "beginner",
      "points": 11
    },
    {
      "id": "network-connectivity-debug",
      "title": "Network Connection Troubleshooting",
      "description": "Diagnose why your application can't connect to a database server.",
      "situation": "Your web application can't connect to database server 'db.company.com' on port 5432. You need to systematically check network connectivity and identify where the connection is failing.",
      "codeExample": "Error: Connection to db.company.com:5432 failed\nTimeout after 30 seconds\n\nNeed to check: DNS resolution, network path, port accessibility",
      "options": [
        "nslookup db.company.com && ping db.company.com && nc -zv db.company.com 5432",
        "ping db.company.com",
        "telnet db.company.com 5432",
        "traceroute db.company.com && netstat -an | grep 5432"
      ],
      "correctAnswer": 0,
      "explanation": "This systematic approach first checks DNS resolution (nslookup), then basic connectivity (ping), and finally tests the specific port (nc -zv). It diagnoses each layer of the connection.",
      "hint": "Network issues can occur at different layers. Which approach tests DNS, connectivity, and port accessibility systematically?",
      "difficulty": "intermediate",
      "points": 14
    },
    {
      "id": "text-processing-pipeline",
      "title": "Log Data Analysis Pipeline",
      "description": "Extract and analyze specific data from web server access logs.",
      "situation": "You need to find the top 10 IP addresses making the most requests in your Apache access log and show their request counts.",
      "codeExample": "Apache log format:\n192.168.1.100 - - [21/Jun/2024:14:23:15 +0000] \"GET /index.html HTTP/1.1\" 200 1024\n10.0.0.50 - - [21/Jun/2024:14:23:16 +0000] \"POST /api/login HTTP/1.1\" 200 256\n\nGoal: Top 10 IPs by request count",
      "options": [
        "cut -d' ' -f1 /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -10",
        "awk '{print $1}' /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -10",
        "grep -o '^[0-9.]*' /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -10",
        "sed 's/ .*//' /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -10"
      ],
      "correctAnswer": 1,
      "explanation": "awk '{print $1}' extracts the first field (IP address), sort groups identical IPs, uniq -c counts occurrences, sort -nr sorts by count in reverse order, and head -10 shows the top 10.",
      "hint": "You need to extract the IP field, count occurrences, and sort by frequency. Which command pipeline efficiently handles this text processing task?",
      "difficulty": "intermediate",
      "points": 15
    },
    {
      "id": "process-management-kill",
      "title": "Stubborn Process Termination",
      "description": "Safely terminate a hung application process that's not responding to normal signals.",
      "situation": "A Java application (PID 1234) is completely unresponsive and consuming 100% CPU. It's not responding to normal termination requests, and you need to stop it without affecting other processes.",
      "codeExample": "$ ps aux | grep java\nuser  1234  99.9  25.0 2048000 1024000 ?  R  14:23  45:32 java -jar myapp.jar\n\nProcess is unresponsive to user input and consuming excessive resources.",
      "options": [
        "kill -9 1234",
        "kill 1234 && sleep 5 && kill -9 1234",
        "kill 1234; if ps -p 1234 > /dev/null; then sleep 10; kill -TERM 1234; sleep 5; kill -KILL 1234; fi",
        "pkill -f 'java -jar myapp.jar'"
      ],
      "correctAnswer": 2,
      "explanation": "This approach tries graceful termination first (SIGTERM), waits, then escalates to SIGKILL only if needed. It checks if the process still exists and follows the proper signal escalation sequence.",
      "hint": "Best practice is to try graceful termination before using force. Which approach follows the proper signal escalation sequence?",
      "difficulty": "intermediate",
      "points": 13
    },
    {
      "id": "find-and-replace-bulk",
      "title": "Bulk Configuration Update",
      "description": "Update configuration values across multiple files in a directory structure.",
      "situation": "You need to change the database host from 'localhost' to 'db.internal' in all .conf files within /etc/myapp/ and its subdirectories, but only if the line contains 'db_host='.",
      "codeExample": "Files contain lines like:\ndb_host=localhost\napi_host=localhost  # Should NOT change this\ncache_host=redis.local\n\nOnly change db_host lines from localhost to db.internal",
      "options": [
        "sed -i 's/localhost/db.internal/g' /etc/myapp/*.conf",
        "find /etc/myapp -name '*.conf' -exec sed -i 's/localhost/db.internal/g' {} \\;",
        "find /etc/myapp -name '*.conf' -exec sed -i '/db_host=/s/localhost/db.internal/g' {} \\;",
        "grep -r 'db_host=localhost' /etc/myapp --include='*.conf' | sed 's/localhost/db.internal/'"
      ],
      "correctAnswer": 2,
      "explanation": "This command finds all .conf files recursively, then uses sed with a pattern address '/db_host=/' to only modify lines containing 'db_host=', preventing unintended changes to other localhost references.",
      "hint": "You need to be precise about which lines to modify. Which approach only changes localhost on lines that contain 'db_host='?",
      "difficulty": "intermediate",
      "points": 16
    },
    {
      "id": "system-monitoring-performance",
      "title": "Performance Bottleneck Investigation",
      "description": "Identify system bottlenecks during performance issues using command-line tools.",
      "situation": "Your server is experiencing slow response times. You need to check CPU, memory, disk I/O, and network to identify the bottleneck. Users report intermittent timeouts.",
      "codeExample": "Symptoms:\n• Application response time: 30+ seconds (normally <2s)\n• Users getting timeouts\n• No obvious error messages in logs\n\nNeed to check all system resources systematically",
      "options": [
        "top && free -h && df -h",
        "vmstat 1 5 && iostat -x 1 5 && sar -n DEV 1 5",
        "htop && iotop && nethogs",
        "uptime && cat /proc/loadavg && cat /proc/meminfo"
      ],
      "correctAnswer": 1,
      "explanation": "This combination provides comprehensive system monitoring: vmstat shows CPU/memory over time, iostat shows disk I/O statistics, and sar shows network statistics. The '1 5' samples every second for 5 iterations, revealing patterns.",
      "hint": "You need to monitor multiple system resources over time to identify patterns. Which combination provides comprehensive real-time system metrics?",
      "difficulty": "intermediate",
      "points": 17
    },
    {
      "id": "security-audit-files",
      "title": "Security Audit - Suspicious Files",
      "description": "Find potentially compromised files and unusual permissions for security investigation.",
      "situation": "Security team suspects a breach. You need to find files modified in the last 24 hours, world-writable files, and files with unusual ownership in system directories.",
      "codeExample": "Investigation needed:\n• Files modified in last 24 hours in /usr, /bin, /sbin\n• World-writable files that shouldn't be\n• Files owned by unusual users in system directories\n\nSecurity incident response protocol active",
      "options": [
        "find /usr /bin /sbin \\( -mtime -1 -o -perm -002 -o ! -user root \\) -ls | tee /tmp/security_audit.log",
        "find /usr /bin /sbin -mtime -1 -ls",
        "find /usr /bin /sbin -mtime -1 -o -perm -002 -o ! -user root | tee /tmp/security_audit.log",
        "ls -la /usr /bin /sbin | grep $(date +%Y-%m-%d)"
      ],
      "correctAnswer": 0,
      "explanation": "This command uses proper grouping with parentheses to find files that match ANY of the suspicious criteria: recently modified (-mtime -1), world-writable (-perm -002), or not owned by root (! -user root). The -ls provides detailed output and tee logs results.",
      "hint": "You need to find files matching any of several suspicious criteria. Which command properly groups the conditions and logs the detailed results?",
      "difficulty": "advanced",
      "points": 20
    },
    {
      "id": "backup-and-recovery",
      "title": "Emergency Backup and Recovery",
      "description": "Create a compressed backup while the system is running and verify its integrity.",
      "situation": "You need to create an emergency backup of /home/users before a risky system update. The backup must be compressed, exclude cache directories, and include integrity verification.",
      "codeExample": "Requirements:\n• Backup /home/users to /backup/emergency_backup.tar.gz\n• Exclude .cache and .tmp directories\n• Compress for space efficiency\n• Verify backup integrity\n• System must remain operational",
      "options": [
        "tar -czf /backup/emergency_backup.tar.gz /home/users",
        "tar --exclude='*.cache' --exclude='*.tmp' -czf /backup/emergency_backup.tar.gz /home/users && tar -tzf /backup/emergency_backup.tar.gz > /dev/null",
        "tar --exclude='*/.cache' --exclude='*/.tmp' -czf /backup/emergency_backup.tar.gz /home/users && echo $? && tar -tzf /backup/emergency_backup.tar.gz | wc -l",
        "tar --exclude='*/.cache' --exclude='*/.tmp' -czf /backup/emergency_backup.tar.gz -C / home/users && tar -tzf /backup/emergency_backup.tar.gz > /dev/null && echo 'Backup verified successfully'"
      ],
      "correctAnswer": 3,
      "explanation": "This command properly excludes cache/tmp directories with correct patterns, uses -C to avoid absolute paths in the archive, compresses the backup, verifies integrity by listing contents, and provides confirmation of successful verification.",
      "hint": "Consider exclusion patterns, path handling, compression, and verification. Which approach handles all requirements properly including integrity checking?",
      "difficulty": "advanced",
      "points": 22
    },
    {
      "id": "shell-scripting-automation",
      "title": "System Maintenance Automation",
      "description": "Create a maintenance script that handles multiple system cleanup tasks safely.",
      "situation": "You need to automate weekly maintenance: clean old logs (>30 days), remove temp files, update package cache, and restart a service only if configuration changed. Script must handle errors gracefully.",
      "codeExample": "Weekly maintenance tasks:\n1. Remove logs older than 30 days from /var/log/myapp/\n2. Clean /tmp files older than 7 days\n3. Update package manager cache\n4. Restart myapp service only if config changed in last week\n5. Log all actions with timestamps",
      "options": [
        "find /var/log/myapp -mtime +30 -delete\nfind /tmp -mtime +7 -delete\napt update\nservice myapp restart",
        "#!/bin/bash\nset -e\nfind /var/log/myapp -name '*.log' -mtime +30 -delete 2>/dev/null || true\nfind /tmp -mtime +7 -type f -delete 2>/dev/null || true\napt update -qq\nif [ $(find /etc/myapp/ -name '*.conf' -mtime -7 | wc -l) -gt 0 ]; then\n  systemctl restart myapp\nfi",
        "crontab -e\n0 2 * * 0 find /var/log/myapp -mtime +30 -delete && find /tmp -mtime +7 -delete",
        "#!/bin/bash\nset -euo pipefail\nlog() { echo \"$(date): $1\" | tee -a /var/log/maintenance.log; }\nlog \"Starting maintenance\"\nfind /var/log/myapp -name '*.log' -mtime +30 -delete && log \"Old logs cleaned\" || log \"Error cleaning logs\"\nfind /tmp -mtime +7 -type f -delete && log \"Temp files cleaned\" || log \"Error cleaning temp\"\napt update -qq && log \"Package cache updated\" || log \"Error updating cache\"\nif [ $(find /etc/myapp/ -name '*.conf' -mtime -7 | wc -l) -gt 0 ]; then\n  systemctl restart myapp && log \"Service restarted\" || log \"Error restarting service\"\nelse\n  log \"No config changes, service restart skipped\"\nfi\nlog \"Maintenance completed\""
      ],
      "correctAnswer": 3,
      "explanation": "This script includes proper error handling (set -euo pipefail), logging function with timestamps, conditional service restart based on config changes, and comprehensive error reporting. It follows bash scripting best practices for production use.",
      "hint": "Production scripts need error handling, logging, and conditional logic. Which approach includes all these elements and follows scripting best practices?",
      "difficulty": "advanced",
      "points": 25
    }
  ]
}
