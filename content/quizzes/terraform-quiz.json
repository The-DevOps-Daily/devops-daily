{
  "id": "terraform-quiz",
  "title": "Terraform Fundamentals Quiz",
  "description": "Test your Infrastructure as Code knowledge with practical Terraform scenarios and best practices",
  "category": "Terraform",
  "icon": "Terminal",
  "totalPoints": 88,
  "theme": {
    "primaryColor": "purple",
    "gradientFrom": "from-purple-600",
    "gradientTo": "to-pink-600"
  },
  "metadata": {
    "estimatedTime": "15-18 minutes",
    "difficultyLevels": {
      "beginner": 3,
      "intermediate": 3,
      "advanced": 1
    },
    "createdDate": "2024-11-15"
  },
  "questions": [
    {
      "id": "basic-resource-creation",
      "title": "Creating Your First Resource",
      "description": "What's the correct way to create an AWS EC2 instance with Terraform?",
      "situation": "You need to create a basic EC2 instance named 'web-server' using the t2.micro instance type.",
      "codeExample": "# Goal: Create t2.micro EC2 instance\n# Instance should be tagged with Name: web-server",
      "options": [
        "resource \"aws_instance\" \"web_server\" {\n  ami           = \"ami-12345678\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"web-server\"\n  }\n}",
        "resource \"ec2_instance\" \"web_server\" {\n  ami           = \"ami-12345678\"\n  instance_type = \"t2.micro\"\n  name = \"web-server\"\n}",
        "create_instance {\n  type = \"aws_ec2\"\n  ami = \"ami-12345678\"\n  size = \"t2.micro\"\n  name = \"web-server\"\n}",
        "aws_instance \"web_server\" {\n  ami           = \"ami-12345678\"\n  instance_type = \"t2.micro\"\n  tags = [\"Name: web-server\"]\n}"
      ],
      "correctAnswer": 0,
      "explanation": "The correct Terraform syntax uses 'resource' followed by the resource type and name. AWS provider uses 'aws_instance' as the resource type, and tags are specified as a map.",
      "hint": "Think about the basic Terraform resource syntax: resource \"type\" \"name\" { ... }",
      "difficulty": "beginner",
      "points": 8
    },
    {
      "id": "variables-usage",
      "title": "Using Variables",
      "description": "How do you make your Terraform configuration reusable across environments?",
      "situation": "You want to use different instance types for development (t2.micro) and production (t2.large) environments.",
      "codeExample": "# Need: Configurable instance type\n# Dev: t2.micro\n# Prod: t2.large",
      "options": [
        "Use environment variables like $INSTANCE_TYPE",
        "variable \"instance_type\" {\n  description = \"EC2 instance type\"\n  type        = string\n  default     = \"t2.micro\"\n}\n\nresource \"aws_instance\" \"web\" {\n  instance_type = var.instance_type\n}",
        "Create separate .tf files for each environment",
        "Use conditional statements: instance_type = env == \"prod\" ? \"t2.large\" : \"t2.micro\""
      ],
      "correctAnswer": 1,
      "explanation": "Terraform variables are the proper way to make configurations reusable. They support types, descriptions, defaults, and validation, making your infrastructure code more maintainable.",
      "hint": "What Terraform feature is specifically designed for parameterizing configurations?",
      "difficulty": "beginner",
      "points": 10
    },
    {
      "id": "state-management",
      "title": "State File Management",
      "description": "What's the best practice for storing Terraform state in a team environment?",
      "situation": "Multiple team members need to work on the same Terraform configuration without conflicts.",
      "options": [
        "Use remote backend like S3 with state locking via DynamoDB",
        "Each team member keeps their own local state file",
        "Store state file in version control (Git)",
        "Share state file via email or file sharing service"
      ],
      "correctAnswer": 0,
      "explanation": "Remote backends like S3 with DynamoDB locking prevent conflicts, provide state history, and enable team collaboration. Local state files cause conflicts and version control storage exposes sensitive data.",
      "hint": "Consider security, collaboration, and conflict prevention. What approach handles all these concerns?",
      "difficulty": "beginner",
      "points": 12
    },
    {
      "id": "modules-organization",
      "title": "Code Organization with Modules",
      "description": "How should you structure reusable Terraform code?",
      "situation": "You need to create VPCs with subnets and security groups across multiple projects with slight variations.",
      "codeExample": "# Common pattern:\n# - VPC with public/private subnets\n# - Security groups for web/app/db tiers\n# - Used across 5+ projects",
      "options": [
        "Copy and paste the configuration for each project",
        "Create a Terraform module with configurable parameters:\nmodule \"vpc\" {\n  source = \"./modules/vpc\"\n  \n  vpc_cidr = var.vpc_cidr\n  environment = var.environment\n  project_name = var.project_name\n}",
        "Use a single large configuration file for all projects",
        "Create shell scripts to generate Terraform files"
      ],
      "correctAnswer": 1,
      "explanation": "Terraform modules promote reusability, maintainability, and consistency. They encapsulate related resources and can be parameterized for different use cases while maintaining DRY principles.",
      "hint": "What Terraform feature is designed for creating reusable, configurable infrastructure components?",
      "difficulty": "intermediate",
      "points": 13
    },
    {
      "id": "data-sources",
      "title": "Using Existing Resources",
      "description": "How do you reference existing AWS resources in your Terraform configuration?",
      "situation": "You need to launch EC2 instances in an existing VPC that was created outside of Terraform.",
      "codeExample": "# Existing VPC: vpc-12345678\n# Need: Reference existing VPC to create subnets",
      "options": [
        "Hard-code the VPC ID: vpc_id = \"vpc-12345678\"",
        "Import the VPC into Terraform state first",
        "data \"aws_vpc\" \"existing\" {\n  filter {\n    name = \"tag:Name\"\n    values = [\"production-vpc\"]\n  }\n}\n\nresource \"aws_subnet\" \"app\" {\n  vpc_id = data.aws_vpc.existing.id\n}",
        "Create a new VPC instead of using the existing one"
      ],
      "correctAnswer": 2,
      "explanation": "Data sources allow you to query and reference existing resources without managing them in Terraform. This enables integration with existing infrastructure while maintaining clean separation of concerns.",
      "hint": "What Terraform feature lets you query existing resources without managing them?",
      "difficulty": "intermediate",
      "points": 12
    },
    {
      "id": "lifecycle-management",
      "title": "Resource Lifecycle Control",
      "description": "How do you prevent accidental deletion of critical resources?",
      "situation": "You have a production database that should never be accidentally destroyed during terraform apply.",
      "codeExample": "resource \"aws_db_instance\" \"production\" {\n  # Database configuration\n  # Need: Prevent accidental deletion\n}",
      "options": [
        "Add a comment: # DO NOT DELETE",
        "lifecycle {\n  prevent_destroy = true\n}",
        "Use separate Terraform workspace for production",
        "create_before_destroy = false"
      ],
      "correctAnswer": 1,
      "explanation": "The lifecycle.prevent_destroy meta-argument prevents Terraform from destroying the resource, even if the configuration is removed. This is essential for protecting critical resources like databases.",
      "hint": "What Terraform meta-argument is specifically designed to prevent resource destruction?",
      "difficulty": "intermediate",
      "points": 15
    },
    {
      "id": "advanced-provisioning",
      "title": "Complex Provisioning Scenario",
      "description": "How do you handle dependencies between resources that Terraform can't automatically detect?",
      "situation": "Your application servers need to start only after the database is fully initialized and ready to accept connections.",
      "codeExample": "# Database takes 5+ minutes to initialize\n# App servers should wait for DB to be ready\n# Terraform doesn't know about the initialization delay",
      "options": [
        "Use time_sleep resource or null_resource with local-exec provisioner",
        "depends_on = [aws_db_instance.database]",
        "Run terraform apply twice",
        "Use separate terraform configurations"
      ],
      "correctAnswer": 0,
      "explanation": "While depends_on handles resource creation order, it doesn't wait for service readiness. time_sleep or null_resource with local-exec can implement custom waiting logic or health checks before proceeding.",
      "hint": "Sometimes you need to wait for more than just resource creation. What options handle custom timing or health checks?",
      "difficulty": "advanced",
      "points": 18
    }
  ]
}
